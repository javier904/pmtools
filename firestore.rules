rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ════════════════════════════════════════════════════════════════════════════
    // HELPER FUNCTIONS
    // ════════════════════════════════════════════════════════════════════════════

    /// Verifica che l'utente sia autenticato
    function isAuthenticated() {
      return request.auth != null;
    }

    /// Ottiene l'email dell'utente autenticato (lowercase)
    function userEmail() {
      return request.auth.token.email.lower();
    }

    /// Verifica che l'utente sia il proprietario (campo createdBy)
    function isOwner(resource) {
      return userEmail() == resource.data.get('createdBy', '').lower();
    }

    /// Verifica che l'utente sia il proprietario tramite ownerEmail
    function isOwnerByEmail(resource) {
      return userEmail() == resource.data.get('ownerEmail', '').lower();
    }

    /// Verifica che l'utente sia nell'array participantEmails
    /// NOTA: Gli email nel array DEVONO essere lowercase per il match
    function isParticipantByArray(resource) {
      return userEmail() in resource.data.get('participantEmails', []);
    }

    /// Verifica che l'utente sia owner tramite la mappa participants
    /// Utile come fallback quando createdBy potrebbe non matchare
    function isOwnerInParticipantsMap(resource) {
      let emailKey = userEmail().replace('\\.', '_DOT_');
      return emailKey in resource.data.get('participants', {}) &&
             resource.data.participants[emailKey].get('role', '') == 'owner';
    }

    /// Verifica owner tramite QUALSIASI metodo (createdBy, ownerEmail, o participants map)
    function isOwnerAnyMethod(resource) {
      return isOwner(resource) ||
             isOwnerByEmail(resource) ||
             isOwnerInParticipantsMap(resource);
    }

    /// Verifica owner o partecipante (via participantEmails array)
    function canAccessByParticipantEmails(resource) {
      return isOwner(resource) || isParticipantByArray(resource);
    }

    /// Verifica che l'utente sia nella lista pending
    function isPending(resource) {
      return userEmail() in resource.data.get('pendingEmails', []);
    }

    /// Verifica se l'utente è Facilitatore (Session Owner o Ruolo Facilitator)
    function isFacilitator(resource) {
      let emailKey = userEmail().replace('\\.', '_DOT_');
      return isOwner(resource) || 
             (emailKey in resource.data.participants && resource.data.participants[emailKey].role == 'facilitator');
    }

    /// Verifica se l'utente può votare (Voter o Facilitator)
    function isVoter(resource) {
      let emailKey = userEmail().replace('\\.', '_DOT_');
      return emailKey in resource.data.participants && 
             (resource.data.participants[emailKey].role == 'voter' || resource.data.participants[emailKey].role == 'facilitator');
    }

    // ════════════════════════════════════════════════════════════════════════════
    // PLANNING POKER SESSIONS
    // ════════════════════════════════════════════════════════════════════════════

    match /planning_poker_sessions/{sessionId} {
      // Lettura: creatore, partecipanti, o invitati (pending)
      allow read: if isAuthenticated() && (isOwnerAnyMethod(resource) || canAccessByParticipantEmails(resource) || isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere il creatore)
      allow create: if isAuthenticated() &&
                      request.resource.data.createdBy.lower() == userEmail();

      // Aggiornamento:
      // 1. Facilitatore/Owner: Controllo completo (incluso pendingEmails per inviti)
      // 2. Partecipanti: Solo presenza (heartbeat) e pendingEmails per inviti
      // 3. Pending - ACCETTA: Self-promotion (aggiunge se stesso a participantEmails, rimuove da pending)
      // 4. Pending - RIFIUTA: Solo rimuove se stesso da pendingEmails (senza aggiungersi a participantEmails)
      allow update: if isAuthenticated() && (
        isFacilitator(resource) ||
        isOwnerAnyMethod(resource) ||
        // Partecipanti: heartbeat + possono aggiungere pendingEmails per creare inviti
        (canAccessByParticipantEmails(resource) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['participants', 'updatedAt', 'pendingEmails'])) ||
        // Pending - ACCETTA: aggiunge se stesso a participantEmails e rimuove da pending
        (isPending(resource) &&
         request.resource.data.participantEmails.hasAll(resource.data.participantEmails) &&
         request.resource.data.participantEmails.hasAll([userEmail()]) &&
         request.resource.data.pendingEmails.size() < resource.data.pendingEmails.size()) ||
        // Pending - RIFIUTA: rimuove solo se stesso da pendingEmails (participantEmails rimane invariato)
        (isPending(resource) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pendingEmails', 'updatedAt']) &&
         request.resource.data.pendingEmails.size() < resource.data.pendingEmails.size() &&
         request.resource.data.participantEmails == resource.data.participantEmails)
      );

      // Cancellazione: solo creatore
      allow delete: if isAuthenticated() && isOwnerAnyMethod(resource);

      // Subcollection: stories
      match /stories/{storyId} {
        // Read: Accessibile a tutti i partecipanti
        allow read: if isAuthenticated() &&
                      canAccessByParticipantEmails(
                        get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId))
                      );

        // Create/Delete: Solo Facilitatore
        allow create, delete: if isAuthenticated() &&
                                isFacilitator(get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId)));

        // Update: Facilitatore (Tutto) O Voter (Solo Voti)
        allow update: if isAuthenticated() && (
          isFacilitator(get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId))) ||
          // Voter: può aggiornare solo se tocca 'votes' (e contatori)
          (isVoter(get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId))) &&
           request.resource.data.diff(resource.data).affectedKeys().hasAny(['votes', 'voteCount']))
        );
      }

      // Subcollection: invites (USATA DAL CODICE - planning_poker_invite_service.dart)
      match /invites/{inviteId} {
        // Get: invitato, chi ha invitato, o partecipanti della sessione
        allow get: if isAuthenticated() && (
          resource.data.email.lower() == userEmail() ||
          resource.data.invitedBy.lower() == userEmail() ||
          canAccessByParticipantEmails(get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId)))
        );

        // List: partecipanti della sessione
        allow list: if isAuthenticated() &&
          canAccessByParticipantEmails(get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId)));

        // Create: partecipanti della sessione
        allow create: if isAuthenticated() &&
          canAccessByParticipantEmails(get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId)));

        // Update: chi ha invitato o l'invitato che accetta/rifiuta
        allow update: if isAuthenticated() && (
          resource.data.invitedBy.lower() == userEmail() ||
          ((request.resource.data.status == 'accepted' || request.resource.data.status == 'declined') &&
           resource.data.email.lower() == userEmail())
        );

        // Delete: chi ha invitato
        allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // PLANNING POKER INVITES (TOP-LEVEL - DEPRECATA, mantenuta per backward compatibility)
    // ════════════════════════════════════════════════════════════════════════════

    match /planning_poker_invites/{inviteId} {
      // Get: Solo invitato o chi ha invitato (richiede autenticazione)
      allow get: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // Creazione: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Aggiornamento/Cancellazione: solo chi ha invitato o chi accetta/rifiuta
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        ((request.resource.data.status == 'accepted' || request.resource.data.status == 'declined') &&
         resource.data.email.lower() == userEmail())
      );

      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // EISENHOWER MATRICES
    // ════════════════════════════════════════════════════════════════════════════

    match /eisenhower_matrices/{matrixId} {
      // Lettura: creatore, partecipanti, o invitati (pending)
      allow read: if isAuthenticated() &&
                    (isOwnerAnyMethod(resource) || isParticipantByArray(resource) || isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere il creatore)
      allow create: if isAuthenticated() &&
                      request.resource.data.createdBy.lower() == userEmail();

      // Aggiornamento
      // 1. Owner: controllo totale (via createdBy, ownerEmail, o participants map)
      // 2. Partecipanti: possono modificare (incluso aggiungere pendingEmails per inviti)
      // 3. Pending: possono SOLO accettare invito (self-promotion)
      allow update: if isAuthenticated() && (
        isOwnerAnyMethod(resource) ||
        isParticipantByArray(resource) ||
        // Self-promotion per utenti pending: aggiungono se stessi e si rimuovono da pending
        isPending(resource)
      );

      // Cancellazione: solo creatore
      allow delete: if isAuthenticated() && isOwnerAnyMethod(resource);

      // Subcollection: activities
      match /activities/{activityId} {
        allow read, write: if isAuthenticated() &&
                             (isOwner(get(/databases/$(database)/documents/eisenhower_matrices/$(matrixId))) ||
                              isParticipantByArray(get(/databases/$(database)/documents/eisenhower_matrices/$(matrixId))));
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // EISENHOWER INVITES
    // ════════════════════════════════════════════════════════════════════════════

    match /eisenhower_invites/{inviteId} {
      // Get: Solo invitato o chi ha invitato (richiede autenticazione)
      allow get: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      allow create: if isAuthenticated();
      // Update: chi ha invitato (qualsiasi modifica) O l'invitato (solo per accettare/rifiutare)
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        ((request.resource.data.status == 'accepted' || request.resource.data.status == 'declined') &&
         resource.data.email.lower() == userEmail())
      );
      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // DATA VALIDATION FUNCTIONS
    // ════════════════════════════════════════════════════════════════════════════

    function isValidString(text, min, max) {
      return text is string && text.size() >= min && text.size() <= max;
    }

    function validateProjectData(data) {
      return isValidString(data.name, 1, 100) &&
             isValidString(data.description, 0, 1000) &&
             (data.framework == 'scrum' || data.framework == 'kanban' || data.framework == 'hybrid');
    }

    // ════════════════════════════════════════════════════════════════════════════
    // AGILE PROJECTS
    // ════════════════════════════════════════════════════════════════════════════

    match /agile_projects/{projectId} {
      // Lettura: creatore, partecipanti, o invitati (pending)
      allow read: if isAuthenticated() && (isOwnerAnyMethod(resource) || canAccessByParticipantEmails(resource) || isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere il creatore) + Validazione
      allow create: if isAuthenticated() &&
                      request.resource.data.createdBy.lower() == userEmail() &&
                      validateProjectData(request.resource.data);

      // Aggiornamento stratificato:
      // 1. Owner: Controllo totale (incluso pendingEmails per inviti)
      // 2. Partecipanti: Possono aggiungere a pendingEmails (per inviti) ma NON rimuovere membri
      // 3. Pending - ACCETTA: Possono promuoversi ad attivi (accettare invito)
      // 4. Pending - RIFIUTA: Possono solo rimuoversi da pendingEmails
      allow update: if isAuthenticated() && validateProjectData(request.resource.data) &&
        (
          // Case 1: Owner - controllo totale
          isOwnerAnyMethod(resource) ||

          // Case 2: Partecipante esistente - può aggiungere a pendingEmails per inviti
          (isParticipantByArray(resource) &&
           request.resource.data.participantEmails == resource.data.participantEmails &&
           request.resource.data.get('pendingEmails', []).hasAll(resource.data.get('pendingEmails', []))) ||

          // Case 3: Utente Pending - ACCETTA (aggiunge se stesso e rimuove da pending)
          (isPending(resource) &&
           request.resource.data.participantEmails.hasAll(resource.data.participantEmails) &&
           request.resource.data.participantEmails.hasAll([userEmail()])) ||

          // Case 4: Utente Pending - RIFIUTA (solo rimuove se stesso da pendingEmails)
          (isPending(resource) &&
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pendingEmails', 'updatedAt']) &&
           request.resource.data.get('pendingEmails', []).size() < resource.data.get('pendingEmails', []).size() &&
           request.resource.data.participantEmails == resource.data.participantEmails)
        );

      // Cancellazione: solo creatore
      allow delete: if isAuthenticated() && isOwnerAnyMethod(resource);

      // Subcollections: stories, sprints, retrospectives, audit_logs
      match /stories/{storyId} {
        allow read, write: if isAuthenticated() &&
                             canAccessByParticipantEmails(
                               get(/databases/$(database)/documents/agile_projects/$(projectId))
                             );
      }

      match /sprints/{sprintId} {
        allow read, write: if isAuthenticated() &&
                             canAccessByParticipantEmails(
                               get(/databases/$(database)/documents/agile_projects/$(projectId))
                             );
      }

      match /retrospectives/{retroId} {
        allow read, write: if isAuthenticated() &&
                             canAccessByParticipantEmails(
                               get(/databases/$(database)/documents/agile_projects/$(projectId))
                             );
      }

      match /audit_logs/{logId} {
        // Audit logs: solo lettura per partecipanti, scrittura solo dal sistema
        allow read: if isAuthenticated() &&
                      canAccessByParticipantEmails(
                        get(/databases/$(database)/documents/agile_projects/$(projectId))
                      );
        // Scrittura consentita ai partecipanti (il service scrive gli audit)
        allow write: if isAuthenticated() &&
                       canAccessByParticipantEmails(
                         get(/databases/$(database)/documents/agile_projects/$(projectId))
                       );
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // AGILE INVITES
    // ════════════════════════════════════════════════════════════════════════════

    match /agile_invites/{inviteId} {
      // Get: Solo invitato o chi ha invitato (richiede autenticazione)
      allow get: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // Creazione: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Aggiornamento/Cancellazione: solo chi ha invitato o chi accetta/rifiuta
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        ((request.resource.data.status == 'accepted' || request.resource.data.status == 'declined') &&
         resource.data.email.lower() == userEmail())
      );

      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // SMART TODO LISTS
    // ════════════════════════════════════════════════════════════════════════════

    match /smart_todo_lists/{listId} {
      // Helper per owner di smart_todo_lists (usa ownerEmail)
      // Lettura: owner o partecipanti (via participantEmails) o pending
      allow read: if isAuthenticated() &&
                    (resource.data.get('ownerEmail', '').lower() == userEmail() ||
                     resource.data.get('createdBy', '').lower() == userEmail() ||
                     userEmail() in resource.data.get('participantEmails', []) ||
                     isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere l'owner)
      allow create: if isAuthenticated() &&
                      request.resource.data.get('ownerEmail', '').lower() == userEmail();

      // Aggiornamento: owner o partecipanti (incluso pendingEmails per inviti) o pending (accetta/rifiuta)
      allow update: if isAuthenticated() && (
        resource.data.get('ownerEmail', '').lower() == userEmail() ||
        resource.data.get('createdBy', '').lower() == userEmail() ||
        userEmail() in resource.data.get('participantEmails', []) ||
        // Pending - ACCETTA: aggiunge se stesso a participantEmails
        (isPending(resource) &&
         request.resource.data.get('participantEmails', []).hasAll(resource.data.get('participantEmails', [])) &&
         request.resource.data.get('participantEmails', []).hasAll([userEmail()]) &&
         request.resource.data.get('pendingEmails', []).size() < resource.data.get('pendingEmails', []).size()) ||
        // Pending - RIFIUTA: solo rimuove se stesso da pendingEmails
        (isPending(resource) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pendingEmails', 'updatedAt']) &&
         request.resource.data.get('pendingEmails', []).size() < resource.data.get('pendingEmails', []).size() &&
         request.resource.data.get('participantEmails', []) == resource.data.get('participantEmails', []))
      );

      // Cancellazione: solo owner
      allow delete: if isAuthenticated() &&
                      (resource.data.get('ownerEmail', '').lower() == userEmail() ||
                       resource.data.get('createdBy', '').lower() == userEmail());

      // Subcollection: tasks
      match /smart_todo_tasks/{taskId} {
        allow read, write: if isAuthenticated() &&
                             (get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('ownerEmail', '').lower() == userEmail() ||
                              userEmail() in get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('participantEmails', []));
      }

      // Subcollection: invites (USATA DAL CODICE - smart_todo_invite_service.dart)
      match /invites/{inviteId} {
        // Get: invitato, chi ha invitato, o owner/partecipanti della lista
        allow get: if isAuthenticated() && (
          resource.data.email.lower() == userEmail() ||
          resource.data.invitedBy.lower() == userEmail() ||
          get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('ownerEmail', '').lower() == userEmail() ||
          userEmail() in get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('participantEmails', [])
        );

        // List: owner o partecipanti della lista
        allow list: if isAuthenticated() && (
          get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('ownerEmail', '').lower() == userEmail() ||
          userEmail() in get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('participantEmails', [])
        );

        // Create: owner o partecipanti della lista
        allow create: if isAuthenticated() && (
          get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('ownerEmail', '').lower() == userEmail() ||
          userEmail() in get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('participantEmails', [])
        );

        // Update: chi ha invitato o l'invitato che accetta/rifiuta
        allow update: if isAuthenticated() && (
          resource.data.invitedBy.lower() == userEmail() ||
          ((request.resource.data.status == 'accepted' || request.resource.data.status == 'declined') &&
           resource.data.email.lower() == userEmail())
        );

        // Delete: chi ha invitato
        allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // SMART TODO TASKS - COLLECTION GROUP QUERY (per View Global Tasks)
    // ════════════════════════════════════════════════════════════════════════════

    // Questa regola permette le Collection Group Query su smart_todo_tasks
    // Usata da streamAssignments() e streamTasksByOwner() in smart_todo_service.dart
    match /{path=**}/smart_todo_tasks/{taskId} {
      // Lettura: l'utente deve:
      // 1. Essere assegnato al task (assignedTo array) - per "My Tasks" e "Today"
      // 2. O essere owner della lista parent - per "Owner"
      // 3. O essere partecipante della lista parent
      allow read: if isAuthenticated() && (
        // Case 1: Assegnato al task
        userEmail() in resource.data.get('assignedTo', []) ||
        // Case 2: Owner della lista parent
        get(/databases/$(database)/documents/smart_todo_lists/$(resource.data.listId)).data.get('ownerEmail', '').lower() == userEmail() ||
        // Case 3: Partecipante della lista parent
        userEmail() in get(/databases/$(database)/documents/smart_todo_lists/$(resource.data.listId)).data.get('participantEmails', [])
      );

      // Scrittura: non consentita via collection group (usare il path completo)
      allow write: if false;
    }

    // ════════════════════════════════════════════════════════════════════════════
    // SMART TODO INVITES (TOP-LEVEL - DEPRECATA, mantenuta per backward compatibility)
    // ════════════════════════════════════════════════════════════════════════════

    match /smart_todo_invites/{inviteId} {
      // Get: Solo invitato o chi ha invitato (richiede autenticazione)
      allow get: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // Creazione: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Aggiornamento/Cancellazione: solo chi ha invitato o chi accetta/rifiuta
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        ((request.resource.data.status == 'accepted' || request.resource.data.status == 'declined') &&
         resource.data.email.lower() == userEmail())
      );
      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // RETROSPECTIVES (Top Level)
    // ════════════════════════════════════════════════════════════════════════════

    match /retrospectives/{retroId} {
      // Lettura: Owner, Partecipanti, o Pending
      allow read: if isAuthenticated() && (
        resource.data.get('createdBy', '').lower() == userEmail() ||
        userEmail() in resource.data.get('participantEmails', []) ||
        isPending(resource)
      );

      // Creazione: Utente autenticato che si imposta come creatore
      // SICUREZZA: Impedisce spoofing del campo createdBy
      allow create: if isAuthenticated() &&
                      request.resource.data.get('createdBy', '').lower() == userEmail();

      // Aggiornamento: Owner o Partecipanti (incluso pendingEmails per inviti) o Pending (self-promotion)
      allow update: if isAuthenticated() && (
        resource.data.get('createdBy', '').lower() == userEmail() ||
        userEmail() in resource.data.get('participantEmails', []) ||
        isPending(resource)
      );

      // Cancellazione: Solo Owner
      allow delete: if isAuthenticated() && resource.data.get('createdBy', '').lower() == userEmail();
    }

    match /audit_logs/{logId} {
      // SICUREZZA: Niente lettura dalla collection top-level
      // Gli audit logs dei progetti sono nelle subcollection /agile_projects/{id}/audit_logs
      // Questa collection è solo per scrittura (tracking retrospettive standalone)
      allow read: if false;
      allow create: if isAuthenticated();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // INVITATIONS (UNIFIED COLLECTION)
    // ════════════════════════════════════════════════════════════════════════════

    match /invitations/{inviteId} {
      // Get: Solo invitato o chi ha invitato
      allow get: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // List: Permette query per:
      // 1. Inviti ricevuti (email == userEmail) - per campanella
      // 2. Inviti per una source specifica (sourceType + sourceId) - per tab Inviti
      // NOTA: La sicurezza è garantita dal fatto che solo owner/partecipanti
      // possono accedere alla schermata che mostra gli inviti per una source
      allow list: if isAuthenticated();

      // Create: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Update: chi ha invitato o chi accetta (solo se cambia status)
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        (request.resource.data.status == 'accepted' && resource.data.email.lower() == userEmail()) ||
        (request.resource.data.status == 'declined' && resource.data.email.lower() == userEmail())
      );

      // Delete: chi ha invitato
      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // ESTIMATION ROOM INVITES (TOP-LEVEL - Era mancante!)
    // ════════════════════════════════════════════════════════════════════════════

    match /estimation_room_invites/{inviteId} {
      // Get: Solo invitato o chi ha invitato
      allow get: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // Create: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Update/Delete: chi ha invitato o chi accetta/rifiuta
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        ((request.resource.data.status == 'accepted' || request.resource.data.status == 'declined') &&
         resource.data.email.lower() == userEmail())
      );
      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // RETRO INVITES (TOP-LEVEL - Era mancante!)
    // ════════════════════════════════════════════════════════════════════════════

    match /retro_invites/{inviteId} {
      // Get: Solo invitato o chi ha invitato
      allow get: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // Create: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Update/Delete: chi ha invitato o chi accetta/rifiuta
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        ((request.resource.data.status == 'accepted' || request.resource.data.status == 'declined') &&
         resource.data.email.lower() == userEmail())
      );
      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // USER PROFILES (se necessario in futuro)
    // ════════════════════════════════════════════════════════════════════════════

    match /users/{userId} {
      // Gli utenti possono solo leggere/scrivere il proprio profilo
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
      
      // Accesso a tutte le subcollection dell'utente (subscription, settings, history)
      match /{document=**} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // DENY ALL OTHER COLLECTIONS (default deny)
    // ════════════════════════════════════════════════════════════════════════════

    // Qualsiasi altra collection non esplicitamente definita sara' negata
    // poiche' Firestore nega l'accesso per default se non ci sono regole match

  }
}
