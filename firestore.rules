    // ════════════════════════════════════════════════════════════════════════════
    // HELPER FUNCTIONS
    // ════════════════════════════════════════════════════════════════════════════

    /// Verifica che l'utente sia autenticato
    function isAuthenticated() {
      return request.auth != null;
    }

    /// Ottiene l'email dell'utente autenticato (lowercase)
    function userEmail() {
      return request.auth.token.email.lower();
    }

    /// Verifica che l'utente sia il proprietario (campo createdBy)
    function isOwner(resource) {
      return userEmail() == resource.data.get('createdBy', '').lower();
    }

    /// Verifica che l'utente sia il proprietario tramite ownerEmail
    function isOwnerByEmail(resource) {
      return userEmail() == resource.data.get('ownerEmail', '').lower();
    }

    /// Verifica che l'utente sia nell'array participantEmails
    function isParticipantByArray(resource) {
      return userEmail() in resource.data.get('participantEmails', []);
    }

    /// Verifica owner o partecipante (via participantEmails array)
    function canAccessByParticipantEmails(resource) {
      return isOwner(resource) || isParticipantByArray(resource);
    }

    /// Verifica che l'utente sia nella lista pending
    function isPending(resource) {
      return userEmail() in resource.data.get('pendingEmails', []);
    }

    // ════════════════════════════════════════════════════════════════════════════
    // PLANNING POKER SESSIONS
    // ════════════════════════════════════════════════════════════════════════════

    match /planning_poker_sessions/{sessionId} {
      // Lettura: creatore, partecipanti, o invitati (pending)
      allow read: if isAuthenticated() && (canAccessByParticipantEmails(resource) || isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere il creatore)
      allow create: if isAuthenticated() &&
                      request.resource.data.get('createdBy', '').lower() == userEmail();

      // Aggiornamento: 
      // 1. Creatore/Partecipanti (standard logic)
      // 2. Pending: Self-promotion (accetta invito)
      allow update: if isAuthenticated() && (
        canAccessByParticipantEmails(resource) || 
        (isPending(resource) && 
         request.resource.data.get('participantEmails', []).hasAll(resource.data.get('participantEmails', [])) &&
         request.resource.data.get('participantEmails', []).hasAll([userEmail()]) &&
         request.resource.data.get('pendingEmails', []).size() < resource.data.get('pendingEmails', []).size())
      );

      // Cancellazione: solo creatore
      allow delete: if isAuthenticated() && isOwner(resource);
      
      match /stories/{storyId} {
        allow read, write: if isAuthenticated() &&
                      canAccessByParticipantEmails(
                        get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId))
                      );
      }
    }
    
    // ... (Invites rules are fine, skipping for brevity in this replace call if possible, but replace_file needs contiguous block? No I will assume I can edit the top block and SmartTodo block separately or just edit the functions and Smart Todo)
    // IMPORTANT: I must be careful with replace_file_content.
    // I will replace the HELPER FUNCTIONS block first.
    // Then I will replace the SMART TODO block.
    
    // Actually, I can do it in two chunks using multi_replace_file_content.
    // But I don't have multi_replace.
    // I have replace_file_content.
    
    // I will start with Helper Functions.


    // ════════════════════════════════════════════════════════════════════════════
    // PLANNING POKER SESSIONS
    // ════════════════════════════════════════════════════════════════════════════

    match /planning_poker_sessions/{sessionId} {
      // Lettura: creatore, partecipanti, o invitati (pending)
      allow read: if isAuthenticated() && (canAccessByParticipantEmails(resource) || isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere il creatore)
      allow create: if isAuthenticated() &&
                      request.resource.data.createdBy.lower() == userEmail();

      // Aggiornamento: 
      // 1. Creatore/Partecipanti (standard logic)
      // 2. Pending: Self-promotion (accetta invito)
      allow update: if isAuthenticated() && (
        canAccessByParticipantEmails(resource) || 
        (isPending(resource) && 
         request.resource.data.participantEmails.hasAll(resource.data.participantEmails) &&
         request.resource.data.participantEmails.hasAll([userEmail()]) &&
         request.resource.data.pendingEmails.size() < resource.data.pendingEmails.size())
      );

      // Cancellazione: solo creatore
      allow delete: if isAuthenticated() && isOwner(resource);

      // Subcollection: stories
      match /stories/{storyId} {
        allow read, write: if isAuthenticated() &&
                      canAccessByParticipantEmails(
                        get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId))
                      );
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // PLANNING POKER INVITES
    // ════════════════════════════════════════════════════════════════════════════

    match /planning_poker_invites/{inviteId} {
      // Lettura pubblica per validazione token (necessario per accettare inviti)
      // Get: Pubblico (se conosci ID)
      allow get: if true;
      
      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() || 
        resource.data.invitedBy.lower() == userEmail()
      );

      // Creazione: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Aggiornamento/Cancellazione: solo chi ha invitato o chi accetta (aggiornamento status)
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        (request.resource.data.status == 'accepted' && 
         resource.data.email.lower() == userEmail())
      );

      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // EISENHOWER MATRICES
    // ════════════════════════════════════════════════════════════════════════════

    match /eisenhower_matrices/{matrixId} {
      // Lettura: creatore, partecipanti, o invitati (pending)
      allow read: if isAuthenticated() &&
                    (isOwner(resource) || isParticipantByArray(resource) || isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere il creatore)
      allow create: if isAuthenticated() &&
                      request.resource.data.createdBy.lower() == userEmail();

      // Aggiornamento
      allow update: if isAuthenticated() && (
        isOwner(resource) || 
        isParticipantByArray(resource) ||
        (isPending(resource) && 
         request.resource.data.participantEmails.hasAll(resource.data.participantEmails) &&
         request.resource.data.participantEmails.hasAll([userEmail()]) &&
         request.resource.data.pendingEmails.size() < resource.data.pendingEmails.size())
      );

      // Cancellazione: solo creatore
      allow delete: if isAuthenticated() && isOwner(resource);

      // Subcollection: activities
      match /activities/{activityId} {
        allow read, write: if isAuthenticated() &&
                             (isOwner(get(/databases/$(database)/documents/eisenhower_matrices/$(matrixId))) ||
                              isParticipantByArray(get(/databases/$(database)/documents/eisenhower_matrices/$(matrixId))));
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // EISENHOWER INVITES
    // ════════════════════════════════════════════════════════════════════════════

    match /eisenhower_invites/{inviteId} {
      allow get: if true;
      
      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() || 
        resource.data.invitedBy.lower() == userEmail()
      );

      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        (request.resource.data.status == 'accepted' && resource.data.email.lower() == userEmail())
      );
      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // DATA VALIDATION FUNCTIONS
    // ════════════════════════════════════════════════════════════════════════════

    function isValidString(text, min, max) {
      return text is string && text.size() >= min && text.size() <= max;
    }

    function validateProjectData(data) {
      return isValidString(data.name, 1, 100) &&
             isValidString(data.description, 0, 1000) &&
             (data.framework == 'scrum' || data.framework == 'kanban' || data.framework == 'hybrid');
    }

    // ════════════════════════════════════════════════════════════════════════════
    // AGILE PROJECTS
    // ════════════════════════════════════════════════════════════════════════════

    match /agile_projects/{projectId} {
      // Lettura: creatore, partecipanti, o invitati (pending)
      allow read: if isAuthenticated() && (canAccessByParticipantEmails(resource) || isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere il creatore) + Validazione
      allow create: if isAuthenticated() &&
                      request.resource.data.createdBy.lower() == userEmail() &&
                      validateProjectData(request.resource.data);

      // Aggiornamento stratificato:
      // 1. Owner: Controllo totale
      // 2. Partecipanti: Possono modificare dati ma NON aggiungere/rimuovere membri (Anti-Spam)
      // 3. Pending: Possono SOLO promuoversi ad attivi (accettare invito)
      allow update: if isAuthenticated() && validateProjectData(request.resource.data) &&
        (
          // Case 1: Owner
          isOwner(resource) ||
          
          // Case 2: Partecipante esistente (non può toccare le liste utenti)
          (isParticipantByArray(resource) && 
           request.resource.data.participantEmails == resource.data.participantEmails &&
           request.resource.data.get('pendingEmails', []) == resource.data.get('pendingEmails', [])) ||
           
          // Case 3: Utente Pending (Self-promotion: aggiunge se stesso e rimuove da pending)
          (isPending(resource) && 
           request.resource.data.participantEmails.hasAll(resource.data.participantEmails) &&
           request.resource.data.participantEmails.hasAll([userEmail()]))
        );

      // Cancellazione: solo creatore
      allow delete: if isAuthenticated() && isOwner(resource);

      // Subcollections: stories, sprints, retrospectives, audit_logs
      match /stories/{storyId} {
        allow read, write: if isAuthenticated() &&
                             canAccessByParticipantEmails(
                               get(/databases/$(database)/documents/agile_projects/$(projectId))
                             );
      }

      match /sprints/{sprintId} {
        allow read, write: if isAuthenticated() &&
                             canAccessByParticipantEmails(
                               get(/databases/$(database)/documents/agile_projects/$(projectId))
                             );
      }

      match /retrospectives/{retroId} {
        allow read, write: if isAuthenticated() &&
                             canAccessByParticipantEmails(
                               get(/databases/$(database)/documents/agile_projects/$(projectId))
                             );
      }

      match /audit_logs/{logId} {
        // Audit logs: solo lettura per partecipanti, scrittura solo dal sistema
        allow read: if isAuthenticated() &&
                      canAccessByParticipantEmails(
                        get(/databases/$(database)/documents/agile_projects/$(projectId))
                      );
        // Scrittura consentita ai partecipanti (il service scrive gli audit)
        allow write: if isAuthenticated() &&
                       canAccessByParticipantEmails(
                         get(/databases/$(database)/documents/agile_projects/$(projectId))
                       );
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // AGILE INVITES
    // ════════════════════════════════════════════════════════════════════════════

    match /agile_invites/{inviteId} {
      // Lettura pubblica per validazione token
      allow get: if true;
      
      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() || 
        resource.data.invitedBy.lower() == userEmail()
      );

      // Creazione: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Aggiornamento/Cancellazione: solo chi ha invitato o chi accetta
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        (request.resource.data.status == 'accepted' && resource.data.email.lower() == userEmail())
      );
      
      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // SMART TODO LISTS
    // ════════════════════════════════════════════════════════════════════════════

    match /smart_todo_lists/{listId} {
      // Lettura: owner o partecipanti (via participantEmails) o pending
      allow read: if isAuthenticated() &&
                    (resource.data.get('ownerEmail', '').lower() == userEmail() ||
                     userEmail() in resource.data.get('participantEmails', []) ||
                     isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere l'owner)
      allow create: if isAuthenticated() &&
                      request.resource.data.get('ownerEmail', '').lower() == userEmail();

      // Aggiornamento: owner o partecipanti o pending (self-promotion)
      allow update: if isAuthenticated() && (
        resource.data.get('ownerEmail', '').lower() == userEmail() ||
        userEmail() in resource.data.get('participantEmails', []) ||
        (isPending(resource) && 
         request.resource.data.get('participantEmails', []).hasAll(resource.data.get('participantEmails', [])) &&
         request.resource.data.get('participantEmails', []).hasAll([userEmail()]) &&
         request.resource.data.get('pendingEmails', []).size() < resource.data.get('pendingEmails', []).size())
      );

      // Cancellazione: solo owner
      allow delete: if isAuthenticated() &&
                      resource.data.get('ownerEmail', '').lower() == userEmail();

      // Subcollection: tasks
      match /smart_todo_tasks/{taskId} {
        allow read, write: if isAuthenticated() &&
                             (get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('ownerEmail', '').lower() == userEmail() ||
                              userEmail() in get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('participantEmails', []));
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // SMART TODO INVITES
    // ════════════════════════════════════════════════════════════════════════════

    match /smart_todo_invites/{inviteId} {
      // Lettura pubblica per validazione token
      allow get: if true;
      
      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() || 
        resource.data.invitedBy.lower() == userEmail()
      );

      // Creazione: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Aggiornamento/Cancellazione
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        (request.resource.data.status == 'accepted' && resource.data.email.lower() == userEmail())
      );
      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // RETROSPECTIVES (Top Level)
    // ════════════════════════════════════════════════════════════════════════════

    match /retrospectives/{retroId} {
      // Lettura: Owner o Partecipanti
      allow read: if isAuthenticated() && (
        resource.data.get('createdBy', '').lower() == userEmail() ||
        userEmail() in resource.data.get('participantEmails', [])
      );

      // Creazione: Qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Aggiornamento: Owner o Partecipanti
      allow update: if isAuthenticated() && (
        resource.data.get('createdBy', '').lower() == userEmail() ||
        userEmail() in resource.data.get('participantEmails', [])
      );

      // Cancellazione: Solo Owner
      allow delete: if isAuthenticated() && resource.data.get('createdBy', '').lower() == userEmail();
    }

    match /audit_logs/{logId} {
      allow read: if isAuthenticated(); // TODO: Restrict by project participants if needed
      allow create: if isAuthenticated();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // USER PROFILES (se necessario in futuro)
    // ════════════════════════════════════════════════════════════════════════════

    match /users/{userId} {
      // Gli utenti possono solo leggere/scrivere il proprio profilo
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
      
      // Accesso a tutte le subcollection dell'utente (subscription, settings, history)
      match /{document=**} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // DENY ALL OTHER COLLECTIONS (default deny)
    // ════════════════════════════════════════════════════════════════════════════

    // Qualsiasi altra collection non esplicitamente definita sara' negata
    // poiche' Firestore nega l'accesso per default se non ci sono regole match

  }
}
