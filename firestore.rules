rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ════════════════════════════════════════════════════════════════════════════
    // HELPER FUNCTIONS
    // ════════════════════════════════════════════════════════════════════════════

    /// Verifica che l'utente sia autenticato
    function isAuthenticated() {
      return request.auth != null;
    }

    /// Ottiene l'email dell'utente autenticato (lowercase)
    function userEmail() {
      return request.auth.token.email.lower();
    }

    /// Verifica che l'utente sia il proprietario (campo createdBy)
    function isOwner(resource) {
      return userEmail() == resource.data.get('createdBy', '').lower();
    }

    /// Verifica che l'utente sia il proprietario tramite ownerEmail
    function isOwnerByEmail(resource) {
      return userEmail() == resource.data.get('ownerEmail', '').lower();
    }

    /// Verifica che l'utente sia nell'array participantEmails
    function isParticipantByArray(resource) {
      return userEmail() in resource.data.get('participantEmails', []);
    }

    /// Verifica owner o partecipante (via participantEmails array)
    function canAccessByParticipantEmails(resource) {
      return isOwner(resource) || isParticipantByArray(resource);
    }

    /// Verifica che l'utente sia nella lista pending
    function isPending(resource) {
      return userEmail() in resource.data.get('pendingEmails', []);
    }

    // ════════════════════════════════════════════════════════════════════════════
    // PLANNING POKER SESSIONS
    // ════════════════════════════════════════════════════════════════════════════

    match /planning_poker_sessions/{sessionId} {
      // Lettura: creatore, partecipanti, o invitati (pending)
      allow read: if isAuthenticated() && (canAccessByParticipantEmails(resource) || isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere il creatore)
      allow create: if isAuthenticated() &&
                      request.resource.data.createdBy.lower() == userEmail();

      // Aggiornamento: 
      // 1. Creatore/Partecipanti (standard logic)
      // 2. Pending: Self-promotion (accetta invito)
      allow update: if isAuthenticated() && (
        canAccessByParticipantEmails(resource) || 
        (isPending(resource) && 
         request.resource.data.participantEmails.hasAll(resource.data.participantEmails) &&
         request.resource.data.participantEmails.hasAll([userEmail()]) &&
         request.resource.data.pendingEmails.size() < resource.data.pendingEmails.size())
      );

      // Cancellazione: solo creatore
      allow delete: if isAuthenticated() && isOwner(resource);

      // Subcollection: stories
      match /stories/{storyId} {
        allow read, write: if isAuthenticated() &&
                      canAccessByParticipantEmails(
                        get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId))
                      );
      }

      // Subcollection: invites (USATA DAL CODICE - planning_poker_invite_service.dart)
      match /invites/{inviteId} {
        // Get: invitato, chi ha invitato, o partecipanti della sessione
        allow get: if isAuthenticated() && (
          resource.data.email.lower() == userEmail() ||
          resource.data.invitedBy.lower() == userEmail() ||
          canAccessByParticipantEmails(get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId)))
        );

        // List: partecipanti della sessione
        allow list: if isAuthenticated() &&
          canAccessByParticipantEmails(get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId)));

        // Create: partecipanti della sessione
        allow create: if isAuthenticated() &&
          canAccessByParticipantEmails(get(/databases/$(database)/documents/planning_poker_sessions/$(sessionId)));

        // Update: chi ha invitato o l'invitato che accetta
        allow update: if isAuthenticated() && (
          resource.data.invitedBy.lower() == userEmail() ||
          (request.resource.data.status == 'accepted' && resource.data.email.lower() == userEmail())
        );

        // Delete: chi ha invitato
        allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // PLANNING POKER INVITES (TOP-LEVEL - DEPRECATA, mantenuta per backward compatibility)
    // ════════════════════════════════════════════════════════════════════════════

    match /planning_poker_invites/{inviteId} {
      // Get: Solo invitato o chi ha invitato (richiede autenticazione)
      allow get: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // Creazione: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Aggiornamento/Cancellazione: solo chi ha invitato o chi accetta (aggiornamento status)
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        (request.resource.data.status == 'accepted' &&
         resource.data.email.lower() == userEmail())
      );

      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // EISENHOWER MATRICES
    // ════════════════════════════════════════════════════════════════════════════

    match /eisenhower_matrices/{matrixId} {
      // Lettura: creatore, partecipanti, o invitati (pending)
      allow read: if isAuthenticated() &&
                    (isOwner(resource) || isParticipantByArray(resource) || isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere il creatore)
      allow create: if isAuthenticated() &&
                      request.resource.data.createdBy.lower() == userEmail();

      // Aggiornamento
      allow update: if isAuthenticated() && (
        isOwner(resource) || 
        isParticipantByArray(resource) ||
        (isPending(resource) && 
         request.resource.data.participantEmails.hasAll(resource.data.participantEmails) &&
         request.resource.data.participantEmails.hasAll([userEmail()]) &&
         request.resource.data.pendingEmails.size() < resource.data.pendingEmails.size())
      );

      // Cancellazione: solo creatore
      allow delete: if isAuthenticated() && isOwner(resource);

      // Subcollection: activities
      match /activities/{activityId} {
        allow read, write: if isAuthenticated() &&
                             (isOwner(get(/databases/$(database)/documents/eisenhower_matrices/$(matrixId))) ||
                              isParticipantByArray(get(/databases/$(database)/documents/eisenhower_matrices/$(matrixId))));
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // EISENHOWER INVITES
    // ════════════════════════════════════════════════════════════════════════════

    match /eisenhower_invites/{inviteId} {
      // Get: Solo invitato o chi ha invitato (richiede autenticazione)
      allow get: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        (request.resource.data.status == 'accepted' && resource.data.email.lower() == userEmail())
      );
      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // DATA VALIDATION FUNCTIONS
    // ════════════════════════════════════════════════════════════════════════════

    function isValidString(text, min, max) {
      return text is string && text.size() >= min && text.size() <= max;
    }

    function validateProjectData(data) {
      return isValidString(data.name, 1, 100) &&
             isValidString(data.description, 0, 1000) &&
             (data.framework == 'scrum' || data.framework == 'kanban' || data.framework == 'hybrid');
    }

    // ════════════════════════════════════════════════════════════════════════════
    // AGILE PROJECTS
    // ════════════════════════════════════════════════════════════════════════════

    match /agile_projects/{projectId} {
      // Lettura: creatore, partecipanti, o invitati (pending)
      allow read: if isAuthenticated() && (canAccessByParticipantEmails(resource) || isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere il creatore) + Validazione
      allow create: if isAuthenticated() &&
                      request.resource.data.createdBy.lower() == userEmail() &&
                      validateProjectData(request.resource.data);

      // Aggiornamento stratificato:
      // 1. Owner: Controllo totale
      // 2. Partecipanti: Possono modificare dati ma NON aggiungere/rimuovere membri (Anti-Spam)
      // 3. Pending: Possono SOLO promuoversi ad attivi (accettare invito)
      allow update: if isAuthenticated() && validateProjectData(request.resource.data) &&
        (
          // Case 1: Owner
          isOwner(resource) ||
          
          // Case 2: Partecipante esistente (non può toccare le liste utenti)
          (isParticipantByArray(resource) && 
           request.resource.data.participantEmails == resource.data.participantEmails &&
           request.resource.data.get('pendingEmails', []) == resource.data.get('pendingEmails', [])) ||
           
          // Case 3: Utente Pending (Self-promotion: aggiunge se stesso e rimuove da pending)
          (isPending(resource) && 
           request.resource.data.participantEmails.hasAll(resource.data.participantEmails) &&
           request.resource.data.participantEmails.hasAll([userEmail()]))
        );

      // Cancellazione: solo creatore
      allow delete: if isAuthenticated() && isOwner(resource);

      // Subcollections: stories, sprints, retrospectives, audit_logs
      match /stories/{storyId} {
        allow read, write: if isAuthenticated() &&
                             canAccessByParticipantEmails(
                               get(/databases/$(database)/documents/agile_projects/$(projectId))
                             );
      }

      match /sprints/{sprintId} {
        allow read, write: if isAuthenticated() &&
                             canAccessByParticipantEmails(
                               get(/databases/$(database)/documents/agile_projects/$(projectId))
                             );
      }

      match /retrospectives/{retroId} {
        allow read, write: if isAuthenticated() &&
                             canAccessByParticipantEmails(
                               get(/databases/$(database)/documents/agile_projects/$(projectId))
                             );
      }

      match /audit_logs/{logId} {
        // Audit logs: solo lettura per partecipanti, scrittura solo dal sistema
        allow read: if isAuthenticated() &&
                      canAccessByParticipantEmails(
                        get(/databases/$(database)/documents/agile_projects/$(projectId))
                      );
        // Scrittura consentita ai partecipanti (il service scrive gli audit)
        allow write: if isAuthenticated() &&
                       canAccessByParticipantEmails(
                         get(/databases/$(database)/documents/agile_projects/$(projectId))
                       );
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // AGILE INVITES
    // ════════════════════════════════════════════════════════════════════════════

    match /agile_invites/{inviteId} {
      // Get: Solo invitato o chi ha invitato (richiede autenticazione)
      allow get: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // Creazione: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Aggiornamento/Cancellazione: solo chi ha invitato o chi accetta
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        (request.resource.data.status == 'accepted' && resource.data.email.lower() == userEmail())
      );
      
      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // SMART TODO LISTS
    // ════════════════════════════════════════════════════════════════════════════

    match /smart_todo_lists/{listId} {
      // Lettura: owner o partecipanti (via participantEmails) o pending
      allow read: if isAuthenticated() &&
                    (resource.data.get('ownerEmail', '').lower() == userEmail() ||
                     userEmail() in resource.data.get('participantEmails', []) ||
                     isPending(resource));

      // Creazione: qualsiasi utente autenticato (deve essere l'owner)
      allow create: if isAuthenticated() &&
                      request.resource.data.get('ownerEmail', '').lower() == userEmail();

      // Aggiornamento: owner o partecipanti o pending (self-promotion)
      allow update: if isAuthenticated() && (
        resource.data.get('ownerEmail', '').lower() == userEmail() ||
        userEmail() in resource.data.get('participantEmails', []) ||
        (isPending(resource) && 
         request.resource.data.get('participantEmails', []).hasAll(resource.data.get('participantEmails', [])) &&
         request.resource.data.get('participantEmails', []).hasAll([userEmail()]) &&
         request.resource.data.get('pendingEmails', []).size() < resource.data.get('pendingEmails', []).size())
      );

      // Cancellazione: solo owner
      allow delete: if isAuthenticated() &&
                      resource.data.get('ownerEmail', '').lower() == userEmail();

      // Subcollection: tasks
      match /smart_todo_tasks/{taskId} {
        allow read, write: if isAuthenticated() &&
                             (get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('ownerEmail', '').lower() == userEmail() ||
                              userEmail() in get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('participantEmails', []));
      }

      // Subcollection: invites (USATA DAL CODICE - smart_todo_invite_service.dart)
      match /invites/{inviteId} {
        // Get: invitato, chi ha invitato, o owner/partecipanti della lista
        allow get: if isAuthenticated() && (
          resource.data.email.lower() == userEmail() ||
          resource.data.invitedBy.lower() == userEmail() ||
          get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('ownerEmail', '').lower() == userEmail() ||
          userEmail() in get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('participantEmails', [])
        );

        // List: owner o partecipanti della lista
        allow list: if isAuthenticated() && (
          get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('ownerEmail', '').lower() == userEmail() ||
          userEmail() in get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('participantEmails', [])
        );

        // Create: owner o partecipanti della lista
        allow create: if isAuthenticated() && (
          get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('ownerEmail', '').lower() == userEmail() ||
          userEmail() in get(/databases/$(database)/documents/smart_todo_lists/$(listId)).data.get('participantEmails', [])
        );

        // Update: chi ha invitato o l'invitato che accetta
        allow update: if isAuthenticated() && (
          resource.data.invitedBy.lower() == userEmail() ||
          (request.resource.data.status == 'accepted' && resource.data.email.lower() == userEmail())
        );

        // Delete: chi ha invitato
        allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // SMART TODO INVITES (TOP-LEVEL - DEPRECATA, mantenuta per backward compatibility)
    // ════════════════════════════════════════════════════════════════════════════

    match /smart_todo_invites/{inviteId} {
      // Get: Solo invitato o chi ha invitato (richiede autenticazione)
      allow get: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // List: Solo inviti propri (ricevuti o inviati)
      allow list: if isAuthenticated() && (
        resource.data.email.lower() == userEmail() ||
        resource.data.invitedBy.lower() == userEmail()
      );

      // Creazione: qualsiasi utente autenticato
      allow create: if isAuthenticated();

      // Aggiornamento/Cancellazione
      allow update: if isAuthenticated() && (
        resource.data.invitedBy.lower() == userEmail() ||
        (request.resource.data.status == 'accepted' && resource.data.email.lower() == userEmail())
      );
      allow delete: if isAuthenticated() && resource.data.invitedBy.lower() == userEmail();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // RETROSPECTIVES (Top Level)
    // ════════════════════════════════════════════════════════════════════════════

    match /retrospectives/{retroId} {
      // Lettura: Owner o Partecipanti
      allow read: if isAuthenticated() && (
        resource.data.get('createdBy', '').lower() == userEmail() ||
        userEmail() in resource.data.get('participantEmails', [])
      );

      // Creazione: Utente autenticato che si imposta come creatore
      // SICUREZZA: Impedisce spoofing del campo createdBy
      allow create: if isAuthenticated() &&
                      request.resource.data.get('createdBy', '').lower() == userEmail();

      // Aggiornamento: Owner o Partecipanti
      allow update: if isAuthenticated() && (
        resource.data.get('createdBy', '').lower() == userEmail() ||
        userEmail() in resource.data.get('participantEmails', [])
      );

      // Cancellazione: Solo Owner
      allow delete: if isAuthenticated() && resource.data.get('createdBy', '').lower() == userEmail();
    }

    match /audit_logs/{logId} {
      // SICUREZZA: Niente lettura dalla collection top-level
      // Gli audit logs dei progetti sono nelle subcollection /agile_projects/{id}/audit_logs
      // Questa collection è solo per scrittura (tracking retrospettive standalone)
      allow read: if false;
      allow create: if isAuthenticated();
    }

    // ════════════════════════════════════════════════════════════════════════════
    // USER PROFILES (se necessario in futuro)
    // ════════════════════════════════════════════════════════════════════════════

    match /users/{userId} {
      // Gli utenti possono solo leggere/scrivere il proprio profilo
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
      
      // Accesso a tutte le subcollection dell'utente (subscription, settings, history)
      match /{document=**} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // DENY ALL OTHER COLLECTIONS (default deny)
    // ════════════════════════════════════════════════════════════════════════════

    // Qualsiasi altra collection non esplicitamente definita sara' negata
    // poiche' Firestore nega l'accesso per default se non ci sono regole match

  }
}
